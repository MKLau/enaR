import csv
import copy
#remember to either add your own matrix through a list with lists inside it to represent each line of the matrix or give the
#location of your csv file in the first line of main (which will be at the bottom of the code)

def SimplePath(DictionaryRepresentation, Matrix, SimpleList): # this finds the simple paths for the environs

    #Notable variables:
        #queue = the list of all paths which still have the opportunity to continue or have not been deemed finished yet.
                 # Example can be found on attachment
        #SimpleList = the list which will hold all simple paths

    queue = [] #queue starts empty; however, as one traverses through this function (which will loop many times), essentially
               #every path that has been created (and not already come to a close) will be added to queue.
    for x in range(1,(len(Matrix)+1),1): #this essentially is a loop which will have you walk through the dictionary node
                                         # by node so you can find all the different paths for each environ
        string = ''
        string = string + str(x)
        queue.append(string) #must be a string not an integer. Will not work with integer
        while queue: #once you have reached the last node in the dictionary and there are no more entries in queue, this function essentailly stops
            path = queue.pop(0) #gets a path(the first one) from the queue (will be used to find expanded paths or section path off)
            #the statements directly below get the last node from the path. There are many lines of code; however, it all has to do with
            #getting around Python syntax. Every line until (Continue = False) is to get the last node from each path
            #the last node is important, because this function is based around using the last node of a path and inserting that
            #value into the dictionary to see what possible paths (if any) can be created and adding them back into the queue.

            Append = True
            for x in SimpleList:
                if len(SimpleList) > 0 and path == x: #essentially checks to see if it is a repeated path and if it is - it will not be added to Simplelist
                    Append = False
            if Append == True: # if this path has not been seen before - it will be added to the SimpleList
                SimpleList.append(path)
            if len(path)>1 and type(path) == str: #only used if only one entry in the path and it is 10+=
                node = path #you use str     ^ because if there is only one entry in path, it isn't a list it's a string
            else:
                node = path[-1]# this line is used in most cases. gets the last node of the path
                        # enumerate all adjacent nodes, construct a new path and push it into the queue
            Continue = False
            for adjacent in DictionaryRepresentation.get(node, []):# will loop through for all possible nodes (if any) that
                                                                   # the last node of the path links to. Note: if the
                                                                   # original path has no possible next steps, this code
                                                                   # will not be enacted

                NotLoop = True
                Continue = True
                new_path = list(path)
                new_path.append(adjacent) #new_path is the path that is formed when you add one of the nodes that is the next
                                          #step for the original path. For example, if you have
                                          #an original path of ['1','2'] and node 2 connects to 3, 6,and 7, this loop
                                          # will cycle three times to create ['1','2','3'], ['1','2','6']
                                          # and ['1','2','7']
                i = 0
                NPLength = len(new_path)
                while i < (NPLength) and NotLoop == True: # this checks to see if a path is a cycle through checking if
                                                          # a node is repeated. If one is, it will not be considered a path
                                                          #and therefore not added to either queue or SimpleList
                    g = new_path.pop(i)
                    new_path.insert(i,g)
                    for y in new_path[(i+1):]:
                        if g == y:
                            NotLoop = False
                    i += 1
                if NotLoop == True: #if the updated path is not a cycle, it is added back to queue
                    queue.append(new_path)
            #if Continue == False and Append == False:
            #    SimpleList.append(path)
            
            








#you need getNodes for SimplePaths to work
def getNodes(Matrix,DictionaryRepresentation): #this function essentially takes your input matrix and creates a dictionary where
                                               #each entry in the dictionary referes to a node and
                                               #the values corresponding to each entry in the dictionary will be the nodes that that
                                               #node connects to
    CoordinateSystem = [] #Coordinate Systen is a list with lists inside of it that hold all of the nodes that each node connects to

                          #this code (until the while loop) goes through and finds where each 1 is for each line of the Matrix
                          #and gets the corresponding index of that and adds it to CoordinateSystem.
                          #Example: if the first line of your matrix (Which will refer to node 1) is [0,0,0,1,1,0]
                          #the first entry into CoordinateSystem will be [4,5]
    for x in Matrix:
        OneNode = []
        for position, item in enumerate(x):
            if item == 1:
                string = ''
                string = string + str((position)+1)
                OneNode.append(string)
        CoordinateSystem.append(OneNode)
    i = 0
          #this essentially just puts the entries in CoordinateSystem into the slot of the Dictionary where they belong
    while i < len(CoordinateSystem):
        x = CoordinateSystem[i]
        if len(x) > 0:
            q = str(i+1)
            DictionaryRepresentation[q] = x
        i+=1


def main():
    #these lines until DictionaryRepresentation all have to do with inputting your Matrix
    with open ('/Users/James/Desktop/marionlake_A.csv', 'Ur') as f: #you need to find the path to the file you want
                                                                    #it will always be different
        reader = csv.reader(f)
        Matrix =  list(reader)
        #print(Matrix)
        i = 0
        while i < (len(Matrix)):
            g = Matrix[i]
            f = [ int(x) for x in g ]
            Matrix[i] = f
            i+=1
        #print(Matrix)
    #Matrix = [[0,1,0,0,0,1],[0,0,1,1,1,0],[0,0,0,1,1,0],[0,1,0,0,1,0],[0,1,0,0,0,1],[0,1,0,0,0,0]] #rows/columns switched
    #this Matrix is the Matrix Dr. Patten used to get his B-Matrix Environs
    DictionaryRepresentation = {}
    getNodes(Matrix,DictionaryRepresentation)
    #print(DictionaryRepresentation)
    SimpleList = []
    SimplePath(DictionaryRepresentation,Matrix,SimpleList)
    print(SimpleList)
main()
